<html>
  <head>
	  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>i5ting_ztree_toc:webpack</title>
		<link href="../preview/toc/style/github-bf51422f4bb36427d391e4b75a1daa083c2d840e.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="../preview/toc/style/github2-d731afd4f624c99a4b19ad69f3083cd6d02b81d5.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="../preview/toc/css/zTreeStyle/zTreeStyle.css" media="all" rel="stylesheet" type="text/css"/>
	  <style>
		pre {
		    counter-reset: line-numbering;
		    border: solid 1px #d9d9d9;
		    border-radius: 0;
		    background: #fff;
		    padding: 0;
		    line-height: 23px;
		    margin-bottom: 30px;
		    white-space: pre;
		    overflow-x: auto;
		    word-break: inherit;
		    word-wrap: inherit;
		}

		pre a::before {
		  content: counter(line-numbering);
		  counter-increment: line-numbering;
		  padding-right: 1em; /* space after numbers */
		  width: 25px;
		  text-align: right;
		  opacity: 0.7;
		  display: inline-block;
		  color: #aaa;
		  background: #eee;
		  margin-right: 16px;
		  padding: 2px 10px;
		  font-size: 13px;
		  -webkit-touch-callout: none;
		  -webkit-user-select: none;
		  -khtml-user-select: none;
		  -moz-user-select: none;
		  -ms-user-select: none;
		  user-select: none;
		}

		pre a:first-of-type::before {
		  padding-top: 10px;
		}

		pre a:last-of-type::before {
		  padding-bottom: 10px;
		}

		pre a:only-of-type::before {
		  padding: 10px;
		}

		.highlight { background-color: #ffffcc } /* RIGHT */
		</style>
  </head>
  <body>
	  <div>
				<div style='width:25%;'>
						<ul id="tree" class="ztree" style='width:100%'>

						</ul>
				</div>
        <div id='readme' style='width:70%;margin-left:20%;'>
          	<article class='markdown-body'>
            	<h1 id="webpack-">webpack从入门到进阶</h1>
<h1 id="-1-">第1章 课程介绍</h1>
<h2 id="-">学什么</h2>
<ul>
<li><a href="https://www.webpackjs.com">webpack官网</a></li>
</ul>
<blockquote>
<p>本质上，<em>webpack</em> 是一个现代 JavaScript 应用程序的<em>静态模块打包器(module bundler)</em>。当 webpack 处理应用程序时，它会递归地构建一个<em>依赖关系图(dependency graph)</em>，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 <em>bundle</em>。</p>
</blockquote>
<p><img src="./images/webpack.png" alt="1556458624028"></p>
<ul>
<li>代码转译</li>
<li>模块合并</li>
<li>混淆压缩</li>
<li>代码分割</li>
<li>自动刷新</li>
<li>代码校验</li>
<li>自动部署</li>
</ul>
<h2 id="-">课程安排</h2>
<ul>
<li>webpack基础配置</li>
<li>webpack高级配置</li>
<li>webpack性能优化</li>
<li>tapable钩子</li>
<li>AST抽象语法树的应用</li>
<li>webpack原理分析, 手写webpack</li>
<li>手写常见的loader和plugin</li>
</ul>
<h2 id="-">学习前提</h2>
<ul>
<li>JS基础</li>
<li>ES6 / ES7 语法</li>
<li>node基础</li>
<li>npm的基本使用</li>
</ul>
<h2 id="-">课程目标</h2>
<ul>
<li>掌握webpack的安装</li>
<li>掌握webpack的基础配置</li>
<li>掌握loader的配置</li>
<li>掌握plugin的配置</li>
<li>了解webpack性能优化</li>
<li>了解webpack中的tapable</li>
<li>了解AST的应用</li>
<li>深入学习webpack原理，手写webpack</li>
</ul>
<h1 id="-2-webpack-">第2章 webpack基础</h1>
<h2 id="webpack-">webpack的安装</h2>
<p>注意：请先自行安装<a href="https://nodejs.org">nodejs</a>最新版的环境</p>
<ul>
<li><p>全局安装webpack</p>
<p><code>npm i webpack webpack-cli -g</code></p>
</li>
<li><p>项目中安装webpack (推荐)</p>
<p><code>npm i webpack webpack-cli -D</code></p>
</li>
</ul>
<h2 id="webpack-">webpack的使用</h2>
<h3 id="webpack-cli">webpack-cli</h3>
<p>npm 5.2 以上的版本中提供了一个<code>npx</code>命令</p>
<p>npx 想要解决的主要问题，就是调用项目内部安装的模块，原理就是在<code>node_modules</code>下的<code>.bin</code> 目录中找到对应的命令执行</p>
<p>使用webpack命令：<code>npx webpack</code></p>
<p>webpack4.0之后可以实现0配置打包构建，0配置的特点就是限制较多，无法自定义很多配置</p>
<p>开发中常用的还是使用webpack配置进行打包构建</p>
<h3 id="webpack-">webpack配置</h3>
<p>webpack有四大核心概念:</p>
<ul>
<li>入口(entry): 程序的入口js</li>
<li>输出(output): 打包后存放的位置</li>
<li>loader: 用于对模块的源代码进行转换</li>
<li><p>插件(plugins): 插件目的在于解决 loader无法实现的<strong>其他事</strong></p>
</li>
<li><p>配置webpack.config.js</p>
</li>
<li>运行<code>npx webpack</code></li>
</ul>
<pre><code class="lang-js">const path = require(&#39;path&#39;)

module.exports = {
  // 入口文件配置
  entry: &#39;./src/index.js&#39;,
  // 出口文件配置项
  output: {
    // 输出的路径，webpack2起就规定必须是绝对路径
    path: path.join(__dirname, &#39;dist&#39;),
    // 输出文件名字
    filename: &#39;bundle.js&#39;
  },
  mode: &#39;development&#39; // 默认为production, 可以手动设置为development, 区别就是是否进行压缩混淆
}
</code></pre>
<p>将<code>npx webpack</code>命令配置到<code>package.json</code>的脚本中</p>
<ol>
<li>配置<code>package.json</code></li>
<li>运行<code>npm run build</code></li>
</ol>
<pre><code class="lang-json">{
  &quot;name&quot;: &quot;webpack-basic&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;main&quot;: &quot;index.js&quot;,
  &quot;license&quot;: &quot;MIT&quot;,
  &quot;scripts&quot;: {
    &quot;build&quot;: &quot;webpack&quot;
  },
  &quot;devDependencies&quot;: {
    &quot;webpack&quot;: &quot;^4.30.0&quot;,
    &quot;webpack-cli&quot;: &quot;^3.3.1&quot;
  }
}
</code></pre>
<h3 id="-">开发时自动编译工具</h3>
<p>每次要编译代码时，手动运行 <code>npm run build</code> 就会变得很麻烦。</p>
<p>webpack 中有几个不同的选项，可以帮助你在代码发生变化后自动编译代码：</p>
<ol>
<li>webpack&#39;s Watch Mode</li>
<li>webpack-dev-server</li>
<li>webpack-dev-middleware</li>
</ol>
<p>多数场景中，可能需要使用 <code>webpack-dev-server</code>，但是不妨探讨一下以上的所有选项。</p>
<h4 id="watch">watch</h4>
<p>在<code>webpack</code>指令后面加上<code>--watch</code>参数即可</p>
<p>主要的作用就是监视本地项目文件的变化, 发现有修改的代码会自动编译打包, 生成输出文件</p>
<ol>
<li><p>配置<code>package.json</code>的scripts<code>&quot;watch&quot;: &quot;webpack --watch&quot;</code></p>
</li>
<li><p>运行<code>npm run watch</code></p>
</li>
</ol>
<p>以上是cli的方式设置watch的参数</p>
<p>还可以通过配置文件对watch的参数进行修改：</p>
<pre><code class="lang-js">const path = require(&#39;path&#39;)

// webpack的配置文件遵循着CommonJS规范
module.exports = {
  entry: &#39;./src/main.js&#39;,
  output: {
    // path.resolve() : 解析当前相对路径的绝对路径
    // path: path.resolve(&#39;./dist/&#39;),
    // path: path.resolve(__dirname, &#39;./dist/&#39;),
    path: path.join(__dirname, &#39;./dist/&#39;),
    filename: &#39;bundle.js&#39;
  },
  mode: &#39;development&#39;,
  watch: true
}
</code></pre>
<p>运行<code>npm run build</code></p>
<h4 id="webpack-dev-server-">webpack-dev-server (推荐)</h4>
<ol>
<li><p>安装<code>devServer</code>：</p>
<p><code>devServer</code>需要依赖<code>webpack</code>，必须在项目依赖中安装<code>webpack</code></p>
<p><code>npm i webpack-dev-server webpack -D</code></p>
</li>
<li><p>index.html中修改 <code>&lt;script src=&quot;/bundle.js&quot;&gt;&lt;/script&gt;</code></p>
</li>
<li><p>运行：<code>npx webpack-dev-server</code></p>
</li>
<li><p>运行：<code>npx webpack-dev-server --hot --open --port 8090</code></p>
</li>
<li><p>配置<code>package.json</code>的scripts：<code>&quot;dev&quot;: &quot;webpack-dev-server --hot --open --port 8090&quot;</code></p>
</li>
<li><p>运行<code>npm run dev</code></p>
</li>
</ol>
<p>devServer会在内存中生成一个打包好的<code>bundle.js</code>，专供开发时使用，打包效率高，修改代码后会自动重新打包以及刷新浏览器，用户体验非常好</p>
<p>以上是cli的方式设置devServer的参数</p>
<p>还可以通过配置文件对devServer的参数进行修改：</p>
<ol>
<li>修改<code>webpack.config.js</code></li>
</ol>
<pre><code class="lang-js">const path = require(&#39;path&#39;)

module.exports = {
  // 入口文件配置
  entry: &#39;./src/index.js&#39;,
  // 出口文件配置项
  output: {
    // 输出的路径，webpack2起就规定必须是绝对路径
    path: path.join(__dirname, &#39;dist&#39;),
    // 输出文件名字
    filename: &#39;bundle.js&#39;
  },
  devServer: {
    port: 8090,
    open: true,
    hot: true
  },
  mode: &#39;development&#39;
}
</code></pre>
<ol start="2">
<li>修改package.json的scripts: <code>&quot;dev&quot;: &quot;webpack-dev-server&quot;</code></li>
<li>运行<code>npm run dev</code></li>
</ol>
<h4 id="html-">html插件</h4>
<ol>
<li>安装html-webpack-plugin插件<code>npm i html-webpack-plugin -D</code></li>
<li>在<code>webpack.config.js</code>中的<code>plugins</code>节点下配置</li>
</ol>
<pre><code class="lang-js">const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;)

plugins: [
    new HtmlWebpackPlugin({
        filename: &#39;index.html&#39;,
        template: &#39;template.html&#39;
    })
]
</code></pre>
<ol>
<li>devServer时根据模板在express项目根目录下生成html文件(类似于devServer生成内存中的bundle.js)</li>
<li>devServer时自动引入bundle.js</li>
<li>打包时会自动生成index.html</li>
</ol>
<h4 id="webpack-dev-middleware">webpack-dev-middleware</h4>
<p><code>webpack-dev-middleware</code> 是一个容器(wrapper)，它可以把 webpack 处理后的文件传递给一个服务器(server)。 <code>webpack-dev-server</code> 在内部使用了它，同时，它也可以作为一个单独的包来使用，以便进行更多自定义设置来实现更多的需求。</p>
<ol>
<li><p>安装 <code>express</code> 和 <code>webpack-dev-middleware</code>：</p>
<p><code>npm i express webpack-dev-middleware -D</code></p>
</li>
<li><p>新建<code>server.js</code></p>
<pre><code class="lang-js">const express = require(&#39;express&#39;);
const webpack = require(&#39;webpack&#39;);
const webpackDevMiddleware = require(&#39;webpack-dev-middleware&#39;);
const config = require(&#39;./webpack.config.js&#39;);

const app = express();
const compiler = webpack(config);

app.use(webpackDevMiddleware(compiler, {
  publicPath: &#39;/&#39;
}));

app.listen(3000, function () {
  console.log(&#39;http://localhost:3000&#39;);
});
</code></pre>
</li>
<li><p>配置<code>package.json</code>中的scripts:<code>&quot;server&quot;: &quot;node server.js&quot;</code></p>
</li>
<li><p>运行: <code>npm run server</code></p>
</li>
</ol>
<p>注意: 如果要使用<code>webpack-dev-middleware</code>, 必须使用<code>html-webpack-plugin</code>插件, 否则html文件无法正确的输出到express服务器的根目录</p>
<h4 id="-">小结</h4>
<p>只有在开发时才需要使用自动编译工具, 例如: webpack-dev-server</p>
<p>项目上线时都会直接使用webpack进行打包构建, 不需要使用这些自动编译工具</p>
<p>自动编译工具只是为了<strong>提高开发体验</strong></p>
<h3 id="-css">处理css</h3>
<ol>
<li>安装<code>npm i css-loader style-loader -D</code></li>
<li>配置<code>webpack.config.js</code></li>
</ol>
<pre><code class="lang-js">  module: {
    rules: [
      // 配置的是用来解析.css文件的loader(style-loader和css-loader)
      {
        // 用正则匹配当前访问的文件的后缀名是  .css
        test: /\.css$/,
        use: [&#39;style-loader&#39;, &#39;css-loader&#39;] // webpack底层调用这些包的顺序是从右到左
      }
    ]
  }
</code></pre>
<p>loader的释义:</p>
<ol>
<li>css-loader: 解析css文件</li>
<li>style-loader: 将解析出来的结果 放到html中, 使其生效</li>
</ol>
<h3 id="-less-sass">处理less 和 sass</h3>
<p><code>npm i less less-loader sass-loader node-sass -D</code></p>
<pre><code class="lang-js">{ test: /\.less$/, use: [&#39;style-loader&#39;, &#39;css-loader&#39;, &#39;less-loader&#39;] },
</code></pre>
<pre><code class="lang-js">{ test: /\.scss$/, use: [&#39;style-loader&#39;, &#39;css-loader&#39;, &#39;sass-loader&#39;] }
</code></pre>
<h3 id="-">处理图片和字体</h3>
<ol>
<li><code>npm i file-loader url-loader -D</code></li>
</ol>
<p>url-loader封装了file-loader, 所以使用url-loader时需要安装file-loader</p>
<pre><code class="lang-js">{
    test: /\.(png|jpg|gif)/,
    use: [{
        loader: &#39;url-loader&#39;,
        options: {
            // limit表示如果图片大于5KB，就以路径形式展示，小于的话就用base64格式展示
            limit: 5 * 1024,
            // 打包输出目录
            outputPath: &#39;images&#39;,
            // 打包输出图片名称
            name: &#39;[name]-[hash:4].[ext]&#39;
        }
    }]
}
</code></pre>
<h3 id="babel">babel</h3>
<ol>
<li><p><code>npm i babel-loader @babel/core @babel/preset-env webpack -D</code></p>
</li>
<li><p>如果需要支持更高级的ES6语法, 可以继续安装插件:</p>
<p><code>npm i @babel/plugin-proposal-class-properties -D</code></p>
<p>也可以根据需要在babel官网找插件进行安装</p>
</li>
</ol>
<pre><code class="lang-js">{
  test: /\.js$/,
  use: {
    loader: &#39;babel-loader&#39;,
    options: {
      presets: [&#39;@babel/env&#39;],
      plugins: [&#39;@babel/plugin-proposal-class-properties&#39;]
    }
  },
  exclude: /node_modules/
}
</code></pre>
<p>官方更建议的做法是在项目根目录下新建一个<code>.babelrc</code>的babel配置文件</p>
<pre><code class="lang-json">{
  &quot;presets&quot;: [&quot;@babel/env&quot;],
  &quot;plugins&quot;: [&quot;@babel/plugin-proposal-class-properties&quot;]
}
</code></pre>
<p>如果需要使用<code>generator</code>，无法直接使用babel进行转换，因为会将<code>generator</code>转换为一个<code>regeneratorRuntime</code>，然后使用<code>mark</code>和<code>wrap</code>来实现<code>generator</code></p>
<p>但由于babel并没有内置<code>regeneratorRuntime</code>，所以无法直接使用</p>
<p>需要安装插件:</p>
<p>​    <code>npm i @babel/plugin-transform-runtime -D</code></p>
<p>同时还需安装运行时依赖:</p>
<p>​    <code>npm i @babel/runtime -D</code></p>
<p>在<code>.babelrc</code>中添加插件:</p>
<pre><code class="lang-json">{
  &quot;presets&quot;: [
    &quot;@babel/env&quot;
  ],
  &quot;plugins&quot;: [
    &quot;@babel/plugin-proposal-class-properties&quot;,
    &quot;@babel/plugin-transform-runtime&quot;
  ]
}
</code></pre>
<p>如果需要使用ES6/7中对象原型提供的新方法，babel默认情况无法转换，即使用了<code>transform-runtime</code>的插件也不支持转换原型上的方法</p>
<p>需要使用另一个模块:</p>
<p>​    <code>npm i @babel/polyfill -S</code></p>
<p>该模块需要在使用新方法的地方直接引入:</p>
<p>​    <code>import &#39;@babel/polyfill&#39;</code></p>
<h3 id="source-map-">source map的使用</h3>
<h4 id="devtool">devtool</h4>
<p>此选项控制是否生成，以及如何生成 source map。</p>
<p>使用 <a href="https://www.webpackjs.com/plugins/source-map-dev-tool-plugin"><code>SourceMapDevToolPlugin</code></a> 进行更细粒度的配置。查看 <a href="https://www.webpackjs.com/loaders/source-map-loader"><code>source-map-loader</code></a> 来处理已有的 source map。</p>
<p>选择一种 <a href="http://blog.teamtreehouse.com/introduction-source-maps">source map</a> 格式来增强调试过程。不同的值会明显影响到构建(build)和重新构建(rebuild)的速度。</p>
<blockquote>
<p>可以直接使用 <code>SourceMapDevToolPlugin</code>/<code>EvalSourceMapDevToolPlugin</code> 来替代使用 <code>devtool</code> 选项，它有更多的选项，但是切勿同时使用 <code>devtool</code> 选项和 <code>SourceMapDevToolPlugin</code>/<code>EvalSourceMapDevToolPlugin</code> 插件。因为<code>devtool</code> 选项在内部添加过这些插件，所以会应用两次插件。</p>
</blockquote>
<table>
<thead>
<tr>
<th>devtool</th>
<th>构建速度</th>
<th>重新构建速度</th>
<th>生产环境</th>
<th>品质(quality)</th>
</tr>
</thead>
<tbody>
<tr>
<td>(none)</td>
<td>+++</td>
<td>+++</td>
<td>yes</td>
<td>打包后的代码</td>
</tr>
<tr>
<td>eval</td>
<td>+++</td>
<td>+++</td>
<td>no</td>
<td>生成后的代码</td>
</tr>
<tr>
<td>cheap-eval-source-map</td>
<td>+</td>
<td>++</td>
<td>no</td>
<td>转换过的代码（仅限行）</td>
</tr>
<tr>
<td>cheap-module-eval-source-map</td>
<td>o</td>
<td>++</td>
<td>no</td>
<td>原始源代码（仅限行）</td>
</tr>
<tr>
<td>eval-source-map</td>
<td>--</td>
<td>+</td>
<td>no</td>
<td>原始源代码</td>
</tr>
<tr>
<td>cheap-source-map</td>
<td>+</td>
<td>o</td>
<td>no</td>
<td>转换过的代码（仅限行）</td>
</tr>
<tr>
<td>cheap-module-source-map</td>
<td>o</td>
<td>-</td>
<td>no</td>
<td>原始源代码（仅限行）</td>
</tr>
<tr>
<td>inline-cheap-source-map</td>
<td>+</td>
<td>o</td>
<td>no</td>
<td>转换过的代码（仅限行）</td>
</tr>
<tr>
<td>inline-cheap-module-source-map</td>
<td>o</td>
<td>-</td>
<td>no</td>
<td>原始源代码（仅限行）</td>
</tr>
<tr>
<td>source-map</td>
<td>--</td>
<td>--</td>
<td>yes</td>
<td>原始源代码</td>
</tr>
<tr>
<td>inline-source-map</td>
<td>--</td>
<td>--</td>
<td>no</td>
<td>原始源代码</td>
</tr>
<tr>
<td>hidden-source-map</td>
<td>--</td>
<td>--</td>
<td>yes</td>
<td>原始源代码</td>
</tr>
<tr>
<td>nosources-source-map</td>
<td>--</td>
<td>--</td>
<td>yes</td>
<td>无源代码内容</td>
</tr>
</tbody>
</table>
<h4 id="-">这么多模式用哪个好？</h4>
<p>开发环境推荐：</p>
<p>​    <strong>cheap-module-eval-source-map</strong></p>
<p>生产环境推荐：</p>
<p>​    <strong>none(不使用source map)</strong></p>
<p>原因如下：</p>
<ol>
<li><strong>使用 cheap 模式可以大幅提高 soure map 生成的效率。</strong>大部分情况我们调试并不关心列信息，而且就算 source map 没有列，有些浏览器引擎（例如 v8） 也会给出列信息。</li>
<li><strong>使用 module 可支持 babel 这种预编译工具，映射转换前的代码</strong>。</li>
<li><strong>使用 eval 方式可大幅提高持续构建效率。</strong>官方文档提供的速度对比表格可以看到 eval 模式的重新构建速度都很快。</li>
<li><strong>使用 eval-source-map 模式可以减少网络请求。</strong>这种模式开启 DataUrl 本身包含完整 sourcemap 信息，并不需要像 sourceURL 那样，浏览器需要发送一个完整请求去获取 sourcemap 文件，这会略微提高点效率。而生产环境中则不宜用 eval，这样会让文件变得极大。</li>
</ol>
<h3 id="-">插件</h3>
<h4 id="clean-webpack-plugin">clean-webpack-plugin</h4>
<p>该插件在<code>npm run build</code>时自动清除<code>dist</code>目录后重新生成，非常方便</p>
<ol>
<li><p>安装插件</p>
<p><code>npm i clean-webpack-plugin -D</code></p>
</li>
<li><p>引入插件</p>
<pre><code class="lang-js">const CleanWebpackPlugin = require(&#39;clean-webpack-plugin&#39;)
</code></pre>
</li>
<li><p>使用插件, 在plugins中直接创建对象即可</p>
<pre><code class="lang-js">plugins: [
    new HtmlWebpackPlugin({
      filename: &#39;index.html&#39;,
      template: &#39;./src/index.html&#39;
    }),
    new CleanWebpackPlugin()
  ],
</code></pre>
</li>
</ol>
<h4 id="copy-webpack-plugin">copy-webpack-plugin</h4>
<ol>
<li><p>安装插件</p>
<p><code>npm i copy-webpack-plugin -D</code></p>
</li>
<li><p>引入插件</p>
<pre><code class="lang-js">const CopyWebpackPlugin = require(&#39;copy-webpack-plugin&#39;)
</code></pre>
</li>
<li><p>使用插件, 在plugins中插件对象并配置源和目标</p>
<p>from: 源, 从哪里拷贝, 可以是相对路径或绝对路径, 推荐绝对路径</p>
<p>to: 目标, 拷贝到哪里去, 相对于<code>output</code>的路径, 同样可以相对路径或绝对路径, 但更推荐相对路径(直接算相对dist目录即可)</p>
<pre><code class="lang-js">plugins: [
    new HtmlWebpackPlugin({
      filename: &#39;index.html&#39;,
      template: &#39;./src/index.html&#39;
    }),
    new CleanWebpackPlugin(),
    new CopyWebpackPlugin([
      {
        from: path.join(__dirname, &#39;assets&#39;),
        to: &#39;assets&#39;
      }
    ])
  ],
</code></pre>
</li>
</ol>
<h4 id="bannerplugin">BannerPlugin</h4>
<p>   这是一个webpack的内置插件，用于给打包的JS文件加上版权注释信息</p>
<ol>
<li><p>引入webpack</p>
<pre><code class="lang-js">const webpack = require(&#39;webpack&#39;)
</code></pre>
</li>
<li><p>创建插件对象</p>
<pre><code class="lang-js">plugins: [
    new HtmlWebpackPlugin({
      filename: &#39;index.html&#39;,
      template: &#39;./src/index.html&#39;
    }),
    new CleanWebpackPlugin(),
    new CopyWebpackPlugin([
      {
        from: path.join(__dirname, &#39;assets&#39;),
        to: &#39;assets&#39;
      }
    ]),
    new webpack.BannerPlugin(&#39;黑马程序员牛逼!&#39;)
  ],
</code></pre>
</li>
</ol>
<h1 id="-3-webpack-">第3章 webpack高级配置</h1>
<h2 id="html-img-">HTML中img标签的图片资源处理</h2>
<ol>
<li><p>安装<code>npm install -S html-withimg-loader</code></p>
</li>
<li><p>在<code>webpack.config.js</code>文件中添加loader</p>
<pre><code class="lang-js">{
    test: /\.(htm|html)$/i,
    loader: &#39;html-withimg-loader&#39;
}
</code></pre>
<p>使用时，只需要在html中正常引用图片即可，webpack会找到对应的资源进行打包，并修改html中的引用路径</p>
</li>
</ol>
<h2 id="-">多页应用打包</h2>
<ol>
<li><p>在<code>webpack.config.js</code>中修改入口和出口配置</p>
<pre><code class="lang-js">  // 1. 修改为多入口
  entry: {
      main: &#39;./src/main.js&#39;,
      other: &#39;./src/other.js&#39;
  },
  output: {
    path: path.join(__dirname, &#39;./dist/&#39;),
    // filename: &#39;bundle.js&#39;,
    // 2. 多入口无法对应一个固定的出口, 所以修改filename为[name]变量
    filename: &#39;[name].js&#39;,
    publicPath: &#39;/&#39;
  },
  plugins: [
      // 3. 如果用了html插件,需要手动配置多入口对应的html文件,将指定其对应的输出文件
      new HtmlWebpackPlugin({
          template: &#39;./index.html&#39;,
          filename: &#39;index.html&#39;,
          chunks: [&#39;main&#39;]
      }),
      new HtmlWebpackPlugin({
          template: &#39;./index.html&#39;,
          filename: &#39;other.html&#39;,
          // chunks: [&#39;other&#39;, &#39;main&#39;]
          chunks: [&#39;other&#39;]
      })
  ]
</code></pre>
</li>
<li><p>修改入口为对象，支持多个js入口，同时修改output输出的文件名为<code>&#39;[name].js&#39;</code>表示各自已入口文件名作为输出文件名，但是<code>html-webpack-plugin</code>不支持此功能，所以需要再拷贝一份插件，用于生成两个html页面，实现多页应用</p>
</li>
</ol>
<h2 id="-">第三方库的两种引入方式</h2>
<p>可以通过<code>expose-loader</code>进行全局变量的注入，同时也可以使用内置插件<code>webpack.ProvidePlugin</code>对每个模块的闭包空间，注入一个变量，自动加载模块，而不必到处 <code>import</code> 或 <code>require</code></p>
<ul>
<li><p>expose-loader <strong>将库引入到全局作用域</strong></p>
<ol>
<li><p>安装<code>expose-loader</code></p>
<p><code>npm i -D expose-loader</code></p>
</li>
<li><p>配置loader</p>
<pre><code class="lang-js">module: {
  rules: [{
    test: require.resolve(&#39;jquery&#39;),
    use: {
      loader: &#39;expose-loader&#39;,
      options: &#39;$&#39;
    }
  }]
}
</code></pre>
<p>tips: <code>require.resolve</code> 用来获取模块的绝对路径。所以这里的loader只会作用于 jquery 模块。并且只在 bundle 中使用到它时，才进行处理。</p>
</li>
</ol>
</li>
<li><p>webpack.ProvidePlugin <strong>将库自动加载到每个模块</strong></p>
<ol>
<li><p>引入webpack</p>
<pre><code class="lang-js">const webpack = require(&#39;webpack&#39;)
</code></pre>
</li>
<li><p>创建插件对象</p>
<p>要自动加载 <code>jquery</code>，我们可以将两个变量都指向对应的 node 模块</p>
<pre><code class="lang-js">new webpack.ProvidePlugin({
  $: &#39;jquery&#39;,
  jQuery: &#39;jquery&#39;
})
</code></pre>
</li>
</ol>
</li>
</ul>
<h2 id="development-production-">Development / Production不同配置文件打包</h2>
<p>项目开发时一般需要使用两套配置文件，用于开发阶段打包（不压缩代码，不优化代码，增加效率）和上线阶段打包（压缩代码，优化代码，打包后直接上线使用）</p>
<p>抽取三个配置文件：</p>
<ul>
<li><p>webpack.base.js</p>
</li>
<li><p>webpack.prod.js</p>
</li>
<li><p>webpack.dev.js</p>
</li>
</ul>
<p>步骤如下：</p>
<ol>
<li><p>将开发环境和生产环境公用的配置放入base中，不同的配置各自放入prod或dev文件中（例如：mode）</p>
</li>
<li><p>然后在dev和prod中使用<code>webpack-merge</code>把自己的配置与base的配置进行合并后导出</p>
<p><code>npm i -D webpack-merge</code></p>
</li>
<li><p>将package.json中的脚本参数进行修改，通过<code>--config</code>手动指定特定的配置文件</p>
</li>
</ol>
<h2 id="-">定义环境变量</h2>
<p>除了区分不同的配置文件进行打包，还需要在开发时知道当前的环境是开发阶段或上线阶段，所以可以借助内置插件<code>DefinePlugin</code>来定义环境变量。最终可以实现开发阶段与上线阶段的api地址自动切换。</p>
<ol>
<li><p>引入webpack</p>
<pre><code class="lang-js">const webpack = require(&#39;webpack&#39;)
</code></pre>
</li>
<li><p>创建插件对象，并定义环境变量</p>
<pre><code class="lang-js">new webpack.DefinePlugin({
  IS_DEV: &#39;false&#39;
})
</code></pre>
</li>
<li><p>在src打包的代码环境下可以直接使用</p>
</li>
</ol>
<h2 id="-devserver-">使用devServer解决跨域问题</h2>
<p>在开发阶段很多时候需要使用到跨域，何为跨域？请看下图：</p>
<p><img src="./images/跨域.png" alt="跨域"></p>
<p>开发阶段往往会遇到上面这种情况，也许将来上线后，前端项目会和后端项目部署在同一个服务器下，并不会有跨域问题，但是由于开发时会用到webpack-dev-server，所以一定会产生跨域的问题</p>
<p>目前解决跨域主要的方案有：</p>
<ol>
<li>jsonp（淘汰）</li>
<li>cors</li>
<li>http proxy</li>
</ol>
<p>此处介绍的使用devServer解决跨域，其实原理就是http proxy</p>
<p>将所有ajax请求发送给devServer服务器，再由devServer服务器做一次转发，发送给数据接口服务器</p>
<p>由于ajax请求是发送给devServer服务器的，所以不存在跨域，而devServer由于是用node平台发送的http请求，自然也不涉及到跨域问题，可以完美解决！</p>
<p><img src="./images/解决跨域.png" alt="解决跨域"></p>
<p>服务器代码（返回一段字符串即可）：</p>
<pre><code class="lang-js">const express = require(&#39;express&#39;)
const app = express()
// const cors = require(&#39;cors&#39;)
// app.use(cors())
app.get(&#39;/api/getUserInfo&#39;, (req, res) =&gt; {
  res.send({
    name: &#39;黑马儿&#39;,
    age: 13
  })
});

app.listen(9999, () =&gt; {
  console.log(&#39;http://localhost:9999!&#39;);
});
</code></pre>
<p>前端需要配置devServer的proxy功能，在<code>webpack.dev.js</code>中进行配置：</p>
<pre><code class="lang-js">devServer: {
    open: true,
    hot: true,
    compress: true,
    port: 3000,
    // contentBase: &#39;./src&#39;
    proxy: {
      &#39;/api&#39;: &#39;http://localhost:9999&#39;
    }
  },
</code></pre>
<p>意为前端请求<code>/api</code>的url时，webpack-dev-server会将请求转发给<code>http://localhost:9999/api</code>处，此时如果请求地址为<code>http://localhost:9999/api/getUserInfo</code>，只需要直接写<code>/api/getUserInfo</code>即可，代码如下：</p>
<pre><code class="lang-js">axios.get(&#39;/api/getUserInfo&#39;).then(result =&gt; console.log(result))
</code></pre>
<h2 id="hmr-">HMR的使用</h2>
<p>需要对某个模块进行热更新时，可以通过<code>module.hot.accept</code>方法进行文件监视</p>
<p>只要模块内容发生变化，就会触发回调函数，从而可以重新读取模块内容，做对应的操作</p>
<pre><code class="lang-js">if (module.hot) {
  module.hot.accept(&#39;./hotmodule.js&#39;, function() {
    console.log(&#39;hotmodule.js更新了&#39;);
    let str = require(&#39;./hotmodule.js&#39;)
    console.log(str)
  })
}
</code></pre>
<h1 id="-4-webpack-">第4章 webpack优化</h1>
<h2 id="production-">production模式打包自带优化</h2>
<ul>
<li><p>tree shaking</p>
<p>tree shaking 是一个术语，通常用于打包时移除 JavaScript 中的未引用的代码(dead-code)，它依赖于 ES6 模块系统中 <code>import</code>和 <code>export</code>的<strong>静态结构</strong>特性。</p>
<p>开发时引入一个模块后，如果只使用其中一个功能，上线打包时只会把用到的功能打包进bundle，其他没用到的功能都不会打包进来，可以实现最基础的优化</p>
</li>
</ul>
<ul>
<li><p>scope hoisting</p>
<p>scope hoisting的作用是将模块之间的关系进行结果推测， 可以让 Webpack 打包出来的代码文件更小、运行的更快</p>
<p>scope hoisting 的实现原理其实很简单：分析出模块之间的依赖关系，尽可能的把打散的模块合并到一个函数中去，但前提是不能造成代码冗余。
因此只有那些被引用了一次的模块才能被合并。</p>
<p>由于 scope hoisting 需要分析出模块之间的依赖关系，因此源码必须采用 ES6 模块化语句，不然它将无法生效。
原因和tree shaking一样。</p>
</li>
</ul>
<ul>
<li><p>代码压缩</p>
<p>所有代码使用UglifyJsPlugin插件进行压缩、混淆</p>
</li>
</ul>
<h2 id="css-">css优化</h2>
<h3 id="-css-">将css提取到独立的文件中</h3>
<p><code>mini-css-extract-plugin</code>是用于将CSS提取为独立的文件的插件，对每个包含css的js文件都会创建一个CSS文件，支持按需加载css和sourceMap</p>
<p>只能用在webpack4中，有如下优势:</p>
<ul>
<li>异步加载</li>
<li>不重复编译，性能很好</li>
<li>容易使用</li>
<li>只针对CSS</li>
</ul>
<p>使用方法：</p>
<ol>
<li><p>安装</p>
<p><code>npm i -D mini-css-extract-plugin</code></p>
</li>
<li><p>在webpack配置文件中引入插件</p>
<pre><code class="lang-js">const MiniCssExtractPlugin = require(&#39;mini-css-extract-plugin&#39;)
</code></pre>
</li>
<li><p>创建插件对象，配置抽离的css文件名，支持placeholder语法</p>
<pre><code class="lang-js">new MiniCssExtractPlugin({
    filename: &#39;[name].css&#39;
})
</code></pre>
</li>
<li><p>将原来配置的所有<code>style-loader</code>替换为<code>MiniCssExtractPlugin.loader</code></p>
<pre><code class="lang-js">{
test: /\.css$/,
// webpack读取loader时 是从右到左的读取, 会将css文件先交给最右侧的loader来处理
// loader的执行顺序是从右到左以管道的方式链式调用
// css-loader: 解析css文件
// style-loader: 将解析出来的结果 放到html中, 使其生效
// use: [&#39;style-loader&#39;, &#39;css-loader&#39;]
use: [MiniCssExtractPlugin.loader, &#39;css-loader&#39;, &#39;postcss-loader&#39;]
},
// { test: /\.less$/, use: [&#39;style-loader&#39;, &#39;css-loader&#39;, &#39;less-loader&#39;] },
{ test: /\.less$/, use: [MiniCssExtractPlugin.loader, &#39;css-loader&#39;, &#39;less-loader&#39;] },
// { test: /\.s(a|c)ss$/, use: [&#39;style-loader&#39;, &#39;css-loader&#39;, &#39;sass-loader&#39;] },
{ test: /\.s(a|c)ss$/, use: [MiniCssExtractPlugin.loader, &#39;css-loader&#39;, &#39;sass-loader&#39;] },
</code></pre>
</li>
</ol>
<h3 id="-css-">自动添加css前缀</h3>
<p>使用<code>postcss</code>，需要用到<code>postcss-loader</code>和<code>autoprefixer</code>插件</p>
<ol>
<li><p>安装</p>
<p><code>npm i -D postcss-loader autoprefixer</code></p>
</li>
<li><p>修改webpack配置文件中的loader，将<code>postcss-loader</code>放置在<code>css-loader</code>的右边（调用链从右到左）</p>
<pre><code class="lang-js">{
test: /\.css$/,
// webpack读取loader时 是从右到左的读取, 会将css文件先交给最右侧的loader来处理
// loader的执行顺序是从右到左以管道的方式链式调用
// css-loader: 解析css文件
// style-loader: 将解析出来的结果 放到html中, 使其生效
// use: [&#39;style-loader&#39;, &#39;css-loader&#39;]
use: [MiniCssExtractPlugin.loader, &#39;css-loader&#39;, &#39;postcss-loader&#39;]
},
// { test: /\.less$/, use: [&#39;style-loader&#39;, &#39;css-loader&#39;, &#39;less-loader&#39;] },
{ test: /\.less$/, use: [MiniCssExtractPlugin.loader, &#39;css-loader&#39;, &#39;postcss-loader&#39;, &#39;less-loader&#39;] },
// { test: /\.s(a|c)ss$/, use: [&#39;style-loader&#39;, &#39;css-loader&#39;, &#39;sass-loader&#39;] },
{ test: /\.s(a|c)ss$/, use: [MiniCssExtractPlugin.loader, &#39;css-loader&#39;, &#39;postcss-loader&#39;, &#39;sass-loader&#39;] },
</code></pre>
</li>
<li><p>项目根目录下添加<code>postcss</code>的配置文件：<code>postcss.config.js</code></p>
</li>
<li><p>在<code>postcss</code>的配置文件中使用插件</p>
<pre><code class="lang-js">module.exports = {
  plugins: [require(&#39;autoprefixer&#39;)]
}
</code></pre>
</li>
</ol>
<h3 id="-css-">开启css压缩</h3>
<p>需要使用<code>optimize-css-assets-webpack-plugin</code>插件来完成css压缩</p>
<p>但是由于配置css压缩时会覆盖掉webpack默认的优化配置，导致JS代码无法压缩，所以还需要手动把JS代码压缩插件导入进来：<code>terser-webpack-plugin</code></p>
<ol>
<li><p>安装</p>
<p><code>npm i -D optimize-css-assets-webpack-plugin terser-webpack-plugin</code></p>
</li>
<li><p>导入插件</p>
<pre><code class="lang-js">const TerserJSPlugin = require(&#39;terser-webpack-plugin&#39;)
const OptimizeCSSAssetsPlugin = require(&#39;optimize-css-assets-webpack-plugin&#39;)
</code></pre>
</li>
<li><p>在webpack配置文件中添加配置节点</p>
<pre><code class="lang-js">optimization: {
  minimizer: [new TerserJSPlugin({}), new OptimizeCSSAssetsPlugin({})],
},
</code></pre>
</li>
</ol>
<p>tips: webpack4默认采用的JS压缩插件为：<code>uglifyjs-webpack-plugin</code>，在<code>mini-css-extract-plugin</code>上一个版本中还推荐使用该插件，但最新的v0.6中建议使用<code>teser-webpack-plugin</code>来完成js代码压缩，具体原因未在官网说明，我们就按照最新版的官方文档来做即可</p>
<h2 id="js-">js代码分离</h2>
<p>Code Splitting是webpack打包时用到的重要的优化特性之一，此特性能够把代码分离到不同的 bundle 中，然后可以按需加载或并行加载这些文件。代码分离可以用于获取更小的 bundle，以及控制资源加载优先级，如果使用合理，会极大影响加载时间。</p>
<p>有三种常用的代码分离方法：</p>
<ul>
<li>入口起点(entry points)：使用<code>entry</code>配置手动地分离代码。</li>
<li>防止重复(prevent duplication)：使用 <code>SplitChunksPlugin</code>去重和分离 chunk。</li>
<li>动态导入(dynamic imports)：通过模块的内联函数调用来分离代码。</li>
</ul>
<h3 id="-">手动配置多入口</h3>
<ol>
<li><p>在webpack配置文件中配置多个入口</p>
<pre><code class="lang-js">entry: {
  main: &#39;./src/main.js&#39;,
  other: &#39;./src/other.js&#39;
},
output: {
  // path.resolve() : 解析当前相对路径的绝对路径
  // path: path.resolve(&#39;./dist/&#39;),
  // path: path.resolve(__dirname, &#39;./dist/&#39;),
  path: path.join(__dirname, &#39;..&#39;, &#39;./dist/&#39;),
  // filename: &#39;bundle.js&#39;,
  filename: &#39;[name].bundle.js&#39;,
  publicPath: &#39;/&#39;
},
</code></pre>
</li>
<li><p>在main.js和other.js中都引入同一个模块，并使用其功能</p>
<p>main.js</p>
<pre><code class="lang-js">import $ from &#39;jquery&#39;

$(function() {
  $(&#39;&lt;div&gt;&lt;/div&gt;&#39;).html(&#39;main&#39;).appendTo(&#39;body&#39;)
})
</code></pre>
<p>other.js</p>
<pre><code class="lang-js">import $ from &#39;jquery&#39;

$(function() {
  $(&#39;&lt;div&gt;&lt;/div&gt;&#39;).html(&#39;other&#39;).appendTo(&#39;body&#39;)
})
</code></pre>
</li>
<li><p>修改package.json的脚本，添加一个使用dev配置文件进行打包的脚本（目的是不压缩代码检查打包的bundle时更方便）</p>
<pre><code class="lang-json">&quot;scripts&quot;: {
    &quot;build&quot;: &quot;webpack --config ./build/webpack.prod.js&quot;,
    &quot;dev-build&quot;: &quot;webpack --config ./build/webpack.dev.js&quot;
}
</code></pre>
</li>
<li><p>运行<code>npm run dev-build</code>，进行打包</p>
</li>
<li><p>查看打包后的结果，发现other.bundle.js和main.bundle.js都同时打包了jQuery源文件</p>
<p><img src="./images/main.bundle.js.png" alt="main"></p>
<p><img src="./images/other.bundle.js.png" alt="other"></p>
</li>
</ol>
<p>这种方法存在一些问题:</p>
<ul>
<li>如果入口 chunks 之间包含重复的模块，那些重复模块都会被引入到各个 bundle 中。</li>
<li>这种方法不够灵活，并且不能将核心应用程序逻辑进行动态拆分代码。</li>
</ul>
<h3 id="-">抽取公共代码</h3>
<p>tips: Webpack v4以上使用的插件为<code>SplitChunksPlugin</code>，以前使用的<code>CommonsChunkPlugin</code>已经被移除了，最新版的webpack只需要在配置文件中的<code>optimization</code>节点下添加一个<code>splitChunks</code>属性即可进行相关配置</p>
<ol>
<li><p>修改webpack配置文件</p>
<pre><code class="lang-js">optimization: {
    splitChunks: {
      chunks: &#39;all&#39;
    }
},
</code></pre>
</li>
<li><p>运行<code>npm run dev-build</code>重新打包</p>
</li>
<li><p>查看<code>dist</code>目录</p>
<p><img src="images/1558771916946.png" alt="1558771916946"></p>
</li>
<li><p>查看<code>vendors~main~other.bundle.js</code>，其实就是把都用到的jQuery打包到了一个单独的js中</p>
<p><img src="images/1558772012664.png" alt="1558772012664"></p>
</li>
</ol>
<h3 id="-">动态导入 (懒加载)</h3>
<p>webpack4默认是允许import语法动态导入的，但是需要babel的插件支持，最新版babel的插件包为：<code>@babel/plugin-syntax-dynamic-import</code>，以前老版本不是<code>@babel</code>开头，已经无法使用，需要注意</p>
<p>动态导入最大的好处是实现了懒加载，用到哪个模块才会加载哪个模块，可以提高SPA应用程序的首屏加载速度，Vue、React、Angular框架的路由懒加载原理一样</p>
<ol>
<li><p>安装babel插件</p>
<p><code>npm install -D @babel/plugin-syntax-dynamic-import</code></p>
</li>
<li><p>修改.babelrc配置文件，添加<code>@babel/plugin-syntax-dynamic-import</code>插件</p>
<pre><code class="lang-json">{
  &quot;presets&quot;: [&quot;@babel/env&quot;],
  &quot;plugins&quot;: [
    &quot;@babel/plugin-proposal-class-properties&quot;,
    &quot;@babel/plugin-transform-runtime&quot;,
    &quot;@babel/plugin-syntax-dynamic-import&quot;
  ]
}
</code></pre>
</li>
<li><p>将jQuery模块进行动态导入</p>
<pre><code class="lang-js">function getComponent() {
  return import(&#39;jquery&#39;).then(({ default: $ }) =&gt; {
    return $(&#39;&lt;div&gt;&lt;/div&gt;&#39;).html(&#39;main&#39;)
  })
}
</code></pre>
</li>
<li><p>给某个按钮添加点击事件，点击后调用getComponent函数创建元素并添加到页面</p>
<pre><code class="lang-js">window.onload = function () {
  document.getElementById(&#39;btn&#39;).onclick = function () {
    getComponent().then(item =&gt; {
      item.appendTo(&#39;body&#39;)
    })
  }
}
</code></pre>
</li>
</ol>
<h3 id="splitchunksplugin-">SplitChunksPlugin配置参数</h3>
<p>webpack4之后，使用<code>SplitChunksPlugin</code>插件替代了以前<code>CommonsChunkPlugin</code></p>
<p>而<code>SplitChunksPlugin</code>的配置，只需要在webpack配置文件中的<code>optimization</code>节点下的<code>splitChunks</code>进行修改即可，如果没有任何修改，则会使用默认配置</p>
<p>默认的<code>SplitChunksPlugin</code> 配置适用于绝大多数用户</p>
<p>webpack 会基于如下默认原则自动分割代码：</p>
<ul>
<li>公用代码块或来自 <em>node_modules</em> 文件夹的组件模块。</li>
<li>打包的代码块大小超过 30k（最小化压缩之前）。</li>
<li>按需加载代码块时，同时发送的请求最大数量不应该超过 5。</li>
<li>页面初始化时，同时发送的请求最大数量不应该超过 3。</li>
</ul>
<p>以下是<code>SplitChunksPlugin</code>的默认配置：</p>
<pre><code class="lang-js">module.exports = {
  //...
  optimization: {
    splitChunks: {
      chunks: &#39;async&#39;, // 只对异步加载的模块进行拆分，可选值还有all | initial
      minSize: 30000, // 模块最少大于30KB才拆分
      maxSize: 0,  // 模块大小无上限，只要大于30KB都拆分
      minChunks: 1, // 模块最少引用一次才会被拆分
      maxAsyncRequests: 5, // 异步加载时同时发送的请求数量最大不能超过5,超过5的部分不拆分
      maxInitialRequests: 3, // 页面初始化时同时发送的请求数量最大不能超过3,超过3的部分不拆分
      automaticNameDelimiter: &#39;~&#39;, // 默认的连接符
      name: true, // 拆分的chunk名,设为true表示根据模块名和CacheGroup的key来自动生成,使用上面连接符连接
      cacheGroups: { // 缓存组配置,上面配置读取完成后进行拆分,如果需要把多个模块拆分到一个文件,就需要缓存,所以命名为缓存组
        vendors: { // 自定义缓存组名
          test: /[\\/]node_modules[\\/]/, // 检查node_modules目录,只要模块在该目录下就使用上面配置拆分到这个组
          priority: -10 // 权重-10,决定了哪个组优先匹配,例如node_modules下有个模块要拆分,同时满足vendors和default组,此时就会分到vendors组,因为-10 &gt; -20
        },
        default: { // 默认缓存组名
          minChunks: 2, // 最少引用两次才会被拆分
          priority: -20, // 权重-20
          reuseExistingChunk: true // 如果主入口中引入了两个模块,其中一个正好也引用了后一个,就会直接复用,无需引用两次
        }
      }
    }
  }
};
</code></pre>
<h2 id="noparse">noParse</h2>
<p>在引入一些第三方模块时，例如jQuery、bootstrap等，我们知道其内部肯定不会依赖其他模块，因为最终我们用到的只是一个单独的js文件或css文件</p>
<p>所以此时如果webpack再去解析他们的内部依赖关系，其实是非常浪费时间的，我们需要阻止webpack浪费精力去解析这些明知道没有依赖的库</p>
<p>可以在webpack配置文件的<code>module</code>节点下加上<code>noParse</code>，并配置正则来确定不需要解析依赖关系的模块</p>
<pre><code class="lang-js">module: {
    noParse: /jquery|bootstrap/
}
</code></pre>
<h2 id="ignoreplugin">IgnorePlugin</h2>
<p>在引入一些第三方模块时，例如moment，内部会做i18n国际化处理，所以会包含很多语言包，而语言包打包时会比较占用空间，如果我们项目只需要用到中文，或者少数语言，可以忽略掉所有的语言包，然后按需引入语言包</p>
<p>从而使得构建效率更高，打包生成的文件更小</p>
<p>需要忽略第三方模块内部依赖的其他模块，只需要三步：</p>
<ol>
<li>首先要找到moment依赖的语言包是什么</li>
<li>使用IgnorePlugin插件忽略其依赖</li>
<li>需要使用某些依赖时自行手动引入</li>
</ol>
<p>具体实现如下：</p>
<ol>
<li><p>通过查看moment的源码来分析：</p>
<pre><code class="lang-js">function loadLocale(name) {
    var oldLocale = null;
    // TODO: Find a better way to register and load all the locales in Node
    if (!locales[name] &amp;&amp; (typeof module !== &#39;undefined&#39;) &amp;&amp;
        module &amp;&amp; module.exports) {
        try {
            oldLocale = globalLocale._abbr;
            var aliasedRequire = require;
            aliasedRequire(&#39;./locale/&#39; + name);
            getSetGlobalLocale(oldLocale);
        } catch (e) {}
    }
    return locales[name];
}

</code></pre>
<p>观察上方代码，同时查看moment目录下确实有locale目录，其中放着所有国家的语言包，可以分析得出：locale目录就是moment所依赖的语言包目录</p>
</li>
<li><p>使用IgnorePlugin插件来忽略掉moment模块的locale目录</p>
<p>在webpack配置文件中安装插件，并传入配置项</p>
<p>参数1：表示要忽略的资源路径</p>
<p>参数2：要忽略的资源上下文（所在哪个目录）</p>
<p>两个参数都是正则对象</p>
<pre><code class="lang-js">new webpack.IgnorePlugin(/\.\/locale/, /moment/)
</code></pre>
</li>
<li><p>使用moment时需要手动引入语言包，否则默认使用英文</p>
<pre><code class="lang-js">import moment from &#39;moment&#39;
import &#39;moment/locale/zh-cn&#39;
moment.locale(&#39;zh-CN&#39;)
console.log(moment().subtract(6, &#39;days&#39;).calendar())
</code></pre>
</li>
</ol>
<h2 id="dllplugin">DllPlugin</h2>
<p>在引入一些第三方模块时，例如vue、react、angular等框架，这些框架的文件一般都是不会修改的，而每次打包都需要去解析它们，也会影响打包速度，哪怕做拆分，也只是提高了上线后用户访问速度，并不会提高构建速度，所以如果需要提高构建速度，应该使用动态链接库的方式，类似于Windows中的dll文件。</p>
<p>借助DllPlugin插件实现将这些框架作为一个个的动态链接库，只构建一次，以后每次构建都只生成自己的业务代码，可以大大提高构建效率！</p>
<p>主要思想在于，将一些不做修改的依赖文件，提前打包，这样我们开发代码发布的时候就不需要再对这部分代码进行打包，从而节省了打包时间。</p>
<p>涉及两个插件：</p>
<ol>
<li><p>DllPlugin</p>
<p>使用一个单独webpack配置创建一个dll文件。并且它还创建一个manifest.json。DllReferencePlugin使用该json文件来做映射依赖性。（这个文件会告诉我们的哪些文件已经提取打包好了）</p>
<p>配置参数：</p>
<ul>
<li>context (可选): manifest文件中请求的上下文，默认为该webpack文件上下文。</li>
<li>name: 公开的dll函数的名称，和output.library保持一致即可。</li>
<li>path: manifest.json生成的文件夹及名字</li>
</ul>
</li>
<li><p>DllReferencePlugin</p>
<p>这个插件用于主webpack配置，它引用的dll需要预先构建的依赖关系。</p>
<ul>
<li><p>context: manifest文件中请求的上下文。</p>
</li>
<li><p>manifest: DllPlugin插件生成的manifest.json</p>
</li>
<li><p>content(可选): 请求的映射模块id(默认为manifest.content)</p>
</li>
<li><p>name(可选): dll暴露的名称</p>
</li>
<li><p>scope(可选): 前缀用于访问dll的内容</p>
</li>
<li><p>sourceType(可选): dll是如何暴露(libraryTarget)</p>
</li>
</ul>
</li>
</ol>
<h3 id="-vue-dll">将Vue项目中的库抽取成Dll</h3>
<ol>
<li><p>准备一份将Vue打包成DLL的webpack配置文件</p>
<p>在build目录下新建一个文件：webpack.vue.js</p>
<p>配置入口：将多个要做成dll的库全放进来</p>
<p>配置出口：一定要设置library属性，将打包好的结果暴露在全局</p>
<p>配置plugin：设置打包后dll文件名和manifest文件所在地</p>
<pre><code class="lang-js">const path = require(&#39;path&#39;)
const webpack = require(&#39;webpack&#39;)
module.exports = {
  mode: &#39;development&#39;,
  entry: {
    vue: [
      &#39;vue/dist/vue.js&#39;,
      &#39;vue-router&#39;
    ]
  },
  output: {
    filename: &#39;[name]_dll.js&#39;,
    path: path.resolve(__dirname, &#39;../dist&#39;),
    library: &#39;[name]_dll&#39;
  },
  plugins: [
    new webpack.DllPlugin({
      name: &#39;[name]_dll&#39;,
      path: path.resolve(__dirname, &#39;../dist/manifest.json&#39;)
    })
  ]
}
</code></pre>
</li>
<li><p>在webpack.base.js中进行插件的配置</p>
<p>使用DLLReferencePlugin指定manifest文件的位置即可</p>
<pre><code class="lang-js">new webpack.DllReferencePlugin({
  manifest: path.resolve(__dirname, &#39;../dist/manifest.json&#39;)
})
</code></pre>
</li>
<li><p>安装add-asset-html-webpack-plugin</p>
<p><code>npm i add-asset-html-webpack-plugin -D</code></p>
</li>
<li><p>配置插件自动添加script标签到HTML中</p>
<pre><code class="lang-js">new AddAssetHtmlWebpackPlugin({
  filepath: path.resolve(__dirname, &#39;../dist/vue_dll.js&#39;)
})
</code></pre>
</li>
</ol>
<h3 id="-react-dll">将React项目中的库抽取成Dll</h3>
<ol>
<li><p>准备一份将React打包成DLL的webpack配置文件</p>
<p>在build目录下新建一个文件：webpack.vue.js</p>
<p>配置入口：将多个要做成dll的库全放进来</p>
<p>配置出口：一定要设置library属性，将打包好的结果暴露在全局</p>
<p>配置plugin：设置打包后dll文件名和manifest文件所在地</p>
<pre><code class="lang-js">const path = require(&#39;path&#39;)
const webpack = require(&#39;webpack&#39;)
module.exports = {
  mode: &#39;development&#39;,
  entry: {
    react: [
      &#39;react&#39;,
      &#39;react-dom&#39;
    ]
  },
  output: {
    filename: &#39;[name]_dll.js&#39;,
    path: path.resolve(__dirname, &#39;../dist&#39;),
    library: &#39;[name]_dll&#39;
  },
  plugins: [
    new webpack.DllPlugin({
      name: &#39;[name]_dll&#39;,
      path: path.resolve(__dirname, &#39;../dist/manifest.json&#39;)
    })
  ]
}
</code></pre>
</li>
<li><p>在webpack.base.js中进行插件的配置</p>
<p>使用DLLReferencePlugin指定manifest文件的位置即可</p>
<pre><code class="lang-js">new webpack.DllReferencePlugin({
  manifest: path.resolve(__dirname, &#39;../dist/manifest.json&#39;)
})
</code></pre>
</li>
<li><p>安装add-asset-html-webpack-plugin</p>
<p><code>npm i add-asset-html-webpack-plugin -D</code></p>
</li>
<li><p>配置插件自动添加script标签到HTML中</p>
<pre><code class="lang-js">new AddAssetHtmlWebpackPlugin({
  filepath: path.resolve(__dirname, &#39;../dist/react_dll.js&#39;)
})
</code></pre>
</li>
</ol>
<h2 id="happypack">Happypack</h2>
<p><img src="images/HappyPack_Workflow.png" alt="A diagram showing the flow between HappyPack&#39;s components"></p>
<p>由于webpack在node环境中运行打包构建，所以是单线程的模式，在打包众多资源时效率会比较低下，早期可以通过<code>Happypack</code>来实现多进程打包。当然，这个问题只出现在低版本的webpack中，现在的webpack性能已经非常强劲了，所以无需使用Happypack也可以实现高性能打包</p>
<p><a href="https://github.com/amireh/happypack">Happypack官网</a></p>
<p>引用官网原文：</p>
<blockquote>
<p><strong>Maintenance mode notice</strong></p>
<p>My interest in the project is fading away mainly because I&#39;m not using JavaScript as much as I was in the past. Additionally, Webpack&#39;s native performance is improving and (I hope) it will soon make this plugin unnecessary.</p>
<p>See the FAQ entry about Webpack 4 and <a href="https://github.com/webpack-contrib/thread-loader">thread-loader</a>.</p>
<p>Contributions are always welcome. Changes I make from this point will be restricted to bug-fixing. If someone wants to take over, feel free to get in touch.</p>
<p>Thanks to everyone who used the library, contributed to it and helped in refining it!!!</p>
</blockquote>
<p>由此可以看出作者已经发现，webpack的性能已经强大到不需要使用该插件了，而且小项目使用该插件反而会导致性能损耗过大，因为开启进程是需要耗时的</p>
<p>使用方法：</p>
<ol>
<li><p>安装插件</p>
<p><code>npm i -D happypack</code></p>
</li>
<li><p>在webpack配置文件中引入插件</p>
<pre><code class="lang-js">const HappyPack = require(&#39;happypack&#39;)
</code></pre>
</li>
<li><p>修改loader的配置规则</p>
<pre><code class="lang-js">{
  test: /.js$/,
  use: {
      loader: &#39;happypack/loader&#39;
    },
  include: path.resolve(__dirname, &#39;../src&#39;),
  exclude: /node_modules/
}
</code></pre>
</li>
<li><p>配置插件</p>
<pre><code class="lang-js">new HappyPack({
    loaders: [ &#39;babel-loader&#39; ]
})
</code></pre>
</li>
<li><p>运行打包命令</p>
<p><code>npm run build</code></p>
</li>
</ol>
<h2 id="-">浏览器缓存</h2>
<p>在做了众多代码分离的优化后，其目的是为了利用浏览器缓存，达到提高访问速度的效果，所以构建项目时做代码分割是必须的，例如将固定的第三方模块抽离，下次修改了业务代码，重新发布上线不重启服务器，用户再次访问服务器就不需要再次加载第三方模块了</p>
<p>但此时会遇到一个新的问题，如果再次打包上线不重启服务器，客户端会把以前的业务代码和第三方模块同时缓存，再次访问时依旧会访问缓存中的业务代码，所以会导致业务代码也无法更新</p>
<p>需要在output节点的filename中使用placeholder语法，根据代码内容生成文件名的hash：</p>
<pre><code class="lang-js">output: {
    // path.resolve() : 解析当前相对路径的绝对路径
    // path: path.resolve(&#39;./dist/&#39;),
    // path: path.resolve(__dirname, &#39;./dist/&#39;),
    path: path.join(__dirname, &#39;..&#39;, &#39;./dist/&#39;),
    // filename: &#39;bundle.js&#39;,
    filename: &#39;[name].[contenthash:8].bundle.js&#39;,
    publicPath: &#39;/&#39;
  },
</code></pre>
<p>之后每次打包业务代码时，如果有改变，会生成新的hash作为文件名，浏览器就不会使用缓存了，而第三方模块不会重新打包生成新的名字，则会继续使用缓存</p>
<h2 id="-">打包分析</h2>
<p>项目构建完成后，需要通过一些工具对打包后的bundle进行分析，通过分析才能总结出一些经验，官方推荐的分析方法有两步完成：</p>
<ol>
<li><p>使用<code>--profile --json</code>参数，以json格式来输出打包后的结果到某个指定文件中</p>
<p><code>webpack --profile --json &gt; stats.json</code></p>
</li>
<li><p>将stats.json文件放入工具中进行分析</p>
<p>官方工具：<a href="https://github.com/webpack/analyse">official analyze tool</a></p>
<p>官方推荐的其他四个工具：</p>
<ul>
<li><a href="https://alexkuz.github.io/webpack-chart/">webpack-chart</a></li>
<li><a href="https://chrisbateman.github.io/webpack-visualizer/">webpack-visualizer</a></li>
<li><a href="https://github.com/webpack-contrib/webpack-bundle-analyzer">webpack-bundle-analyzer</a></li>
<li><a href="https://webpack.jakoblind.no/optimize">webpack bundle optimize helper</a></li>
</ul>
<p>其中webpack-bundle-analyzer是一个插件，可以以插件的方式安装到项目中</p>
</li>
</ol>
<h2 id="prefetching-preloading">Prefetching和Preloading</h2>
<p>在优化访问性能时，除了充分利用浏览器缓存之外，还需要涉及一个性能指标：coverage rate（覆盖率）</p>
<p>可以在Chrome浏览器的控制台中按：ctrl  + shift + p，查找coverage，打开覆盖率面板</p>
<p>开始录制后刷新网页，即可看到每个js文件的覆盖率，以及总的覆盖率</p>
<p><img src="images/1559811338075.png" alt="1559811338075"></p>
<p>想提高覆盖率，需要尽可能多的使用动态导入，也就是懒加载功能，将一切能使用懒加载的地方都是用懒加载，这样可以大大提高覆盖率</p>
<p>但有时候使用懒加载会影响用户体验，所以可以在懒加载时使用魔法注释：Prefetching，是指在首页资源加载完毕后，空闲时间时，将动态导入的资源加载进来，这样即可以提高首屏加载速度，也可以解决懒加载可能会影响用户体验的问题，一举两得！</p>
<pre><code class="lang-js">function getComponent() {
  return import(/* webpackPrefetch: true */ &#39;jquery&#39;).then(({ default: $ }) =&gt; {
    return $(&#39;&lt;div&gt;&lt;/div&gt;&#39;).html(&#39;我是main&#39;)
  })
}
</code></pre>
<h1 id="-5-webpack-">第5章 webpack原理</h1>
<h2 id="-">学习目标</h2>
<ul>
<li>了解webpack打包原理</li>
<li>了解webpack的loader原理</li>
<li>了解webpack的插件原理</li>
<li>了解ast抽象语法树的应用</li>
<li>了解tapable的原理</li>
<li>手写一个简单的webpack</li>
</ul>
<h2 id="-">项目准备工作</h2>
<ol>
<li><p>新建一个项目，起一个炫酷的名字</p>
</li>
<li><p>新建<code>bin</code>目录，将打包工具主程序放入其中</p>
<p>主程序的顶部应当有：<code>#!/usr/bin/env node</code>标识，指定程序执行环境为node</p>
</li>
<li><p>在<code>package.json</code>中配置<code>bin</code>脚本</p>
<pre><code class="lang-json">{
    &quot;bin&quot;: &quot;./bin/itheima-pack.js&quot;
}
</code></pre>
</li>
<li><p>通过<code>npm link</code>链接到全局包中，供本地测试使用</p>
</li>
</ol>
<h2 id="-webpack-bundle-">分析webpack打包的bundle文件</h2>
<p>其内部就是自己实现了一个<code>__webpack_require__</code>函数，递归导入依赖关系</p>
<pre><code class="lang-js">(function (modules) { // webpackBootstrap
  // The module cache
  var installedModules = {};

  // The require function
  function __webpack_require__(moduleId) {

    // Check if module is in cache
    if (installedModules[moduleId]) {
      return installedModules[moduleId].exports;
    }
    // Create a new module (and put it into the cache)
    var module = installedModules[moduleId] = {
      i: moduleId,
      l: false,
      exports: {}
    };

    // Execute the module function
    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

    // Flag the module as loaded
    module.l = true;

    // Return the exports of the module
    return module.exports;
  }

  // Load entry module and return exports
  return __webpack_require__(__webpack_require__.s = &quot;./src/index.js&quot;);
})
  ({
    &quot;./src/index.js&quot;:
      (function (module, exports, __webpack_require__) {
        eval(&quot;let news = __webpack_require__(/*! ./news.js */ \&quot;./src/news.js\&quot;)\r\nconsole.log(news.content)\n\n//# sourceURL=webpack:///./src/index.js?&quot;);
      }),
    &quot;./src/message.js&quot;:
      (function (module, exports) {
        eval(&quot;module.exports = {\r\n  content: &#39;今天要下雨了!!!&#39;\r\n}\n\n//# sourceURL=webpack:///./src/message.js?&quot;);
      }),
    &quot;./src/news.js&quot;:
      (function (module, exports, __webpack_require__) {
        eval(&quot;let message = __webpack_require__(/*! ./message.js */ \&quot;./src/message.js\&quot;)\r\n\r\nmodule.exports = {\r\n  content: &#39;今天有个大新闻,爆炸消息!!!内容是:&#39; + message.content\r\n}\n\n//# sourceURL=webpack:///./src/news.js?&quot;);
      })
  });
</code></pre>
<h2 id="-loader">自定义loader</h2>
<h3 id="-">学习目标</h3>
<p>在学习给自己写的itheima-pack工具添加loader功能之前，得先学习webpack中如何自定义loader，所以学习步骤分为两大步：</p>
<ol>
<li>掌握自定义webpack的loader</li>
<li>学习给itheima-pack添加loader功能并写一个loader</li>
</ol>
<p>webpack以及我们自己写的itheima-pack都只能处理JavaScript文件，如果需要处理其他文件，或者对JavaScript代码做一些操作，则需要用到loader。</p>
<p>loader是webpack中四大核心概念之一，主要功能是将一段匹配规则的代码进行加工处理，生成最终的代码后输出，是webpack打包环节中非常重要的一环。</p>
<blockquote>
<p>loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块，然后你就可以利用 webpack 的打包能力，对它们进行处理。</p>
</blockquote>
<p>之前都使用过别人写好的loader，步骤大致分为：</p>
<ol>
<li>装包</li>
<li>在webpack.config.js中配置module节点下的rules即可，例如babel-loader（省略其他配置，只论loader）</li>
<li>（可选步骤）可能还需要其他的配置，例如babel需要配置presets和plugin</li>
</ol>
<pre><code class="lang-js">const path = require(&#39;path&#39;)

module.exports = {
  entry: &#39;./src/index.js&#39;,
  output: {
    path: path.join(__dirname, &#39;dist&#39;),
    filename: &#39;bundle.js&#39;
  },
  module: {
    rules: [
      { test: /\.js$/, use: &#39;babel-loader&#39; }
    ]
  },
  mode: &#39;development&#39;
}
</code></pre>
<h3 id="-loader">实现一个简单的loader</h3>
<p>loader到底是什么东西？能不能自己写？</p>
<p>答案是肯定的，loader就是一个函数，同样也可以自己来写</p>
<ol>
<li>在项目根目录中新建一个目录存放自己写的loader：</li>
</ol>
<p><img src="./images/1561174288710.png" alt="1561174288710"></p>
<ol start="2">
<li><p>编写myloader.js，其实loader就是对外暴露一个函数</p>
<p>第一个参数就是loader要处理的代码</p>
<pre><code class="lang-js">module.exports = function(source) {
  console.log(source) // 只是简单打印并返回结果，不作任何处理
  return source
}
</code></pre>
</li>
<li><p>同样在webpack.config.js中配置自己写的loader，为了方便演示，直接匹配所有的js文件使用自己的myloader进行处理</p>
<pre><code class="lang-js">const path = require(&#39;path&#39;)

module.exports = {
  entry: &#39;./src/index.js&#39;,
  output: {
    path: path.join(__dirname, &#39;dist&#39;),
    filename: &#39;bundle.js&#39;
  },
  module: {
    rules: [
      { test: /.js$/, use: &#39;./loaders/myloader.js&#39; }
    ]
  },
  mode: &#39;development&#39;
}
</code></pre>
</li>
<li><p>如果需要实现一个简单的loader，例如将js中所有的“今天”替换成“明天”</p>
<p>只需要修改myloader.js的内容如下即可</p>
<pre><code class="lang-js">module.exports = function(source) {
  return source.replace(/今天/g, &#39;明天&#39;)
}
</code></pre>
</li>
<li><p>同时也可以配置多个loader对代码进行处理</p>
<pre><code class="lang-js">const path = require(&#39;path&#39;)

module.exports = {
  entry: &#39;./src/index.js&#39;,
  output: {
    path: path.join(__dirname, &#39;dist&#39;),
    filename: &#39;bundle.js&#39;
  },
  module: {
    rules: [
      { test: /.js$/, use: [&#39;./loaders/myloader2.js&#39;, &#39;./loaders/myloader.js&#39;] }
    ]
  },
  mode: &#39;development&#39;
}
</code></pre>
</li>
<li><p>myloader2.js</p>
<pre><code class="lang-js">module.exports = function(source) {
  return source.replace(/爆炸/g, &#39;小道&#39;)
}
</code></pre>
</li>
</ol>
<h3 id="loader-">loader的分类</h3>
<p>不同类型的loader加载时优先级不同，优先级顺序遵循：</p>
<p>前置 &gt; 行内 &gt; 普通 &gt; 后置</p>
<p>pre: 前置loader</p>
<p>post: 后置loader</p>
<p>指定Rule.enforce的属性即可设置loader的种类，不设置默认为普通loader</p>
<h3 id="-itheima-pack-loader-">在itheima-pack中添加loader的功能</h3>
<p>通过配置loader和手写loader可以发现，其实webpack能支持loader，主要步骤如下：</p>
<ol>
<li>读取webpack.config.js配置文件的module.rules配置项，进行倒序迭代（rules的每项匹配规则按倒序匹配）</li>
<li>根据正则匹配到对应的文件类型，同时再批量导入loader函数</li>
<li>倒序迭代调用所有loader函数（loader的加载顺序从右到左，也是倒叙）</li>
<li>最后返回处理后的代码</li>
</ol>
<p>在实现itheima-pack的loader功能时，同样也可以在加载每个模块时，根据rules的正则来匹配是否满足条件，如果满足条件则加载对应的loader函数并迭代调用</p>
<p>depAnalyse()方法中获取到源码后，读取loader：</p>
<pre><code class="lang-js">let rules = this.config.module.rules
for (let i = rules.length - 1; i &gt;= 0; i--) {
    // console.log(rules[i])
    let {test, use} = rules[i]
    if (test.test(modulePath)) {
        for (let j = use.length - 1; j &gt;= 0; j--) {
            let loaderPath = path.join(this.root, use[j])
            let loader = require(loaderPath)
            source = loader(source)
        }
    }
}
</code></pre>
<h2 id="-">自定义插件</h2>
<h3 id="-">学习目标</h3>
<p>在学习给自己写的itheima-pack工具添加plugin功能之前，得先学习webpack中如何自定义plugin，所以学习步骤分为两大步：</p>
<ol>
<li>掌握自定义webpack的plugin</li>
<li>学习给itheima-pack添加plugin功能并写一个plugin</li>
</ol>
<blockquote>
<p> 插件接口可以帮助用户直接触及到编译过程(compilation process)。 插件可以将处理函数(handler)注册到编译过程中的不同事件点上运行的生命周期钩子函数上。 当执行每个钩子时， 插件能够完全访问到编译(compilation)的当前状态。</p>
</blockquote>
<p>简单理解，自定义插件就是在webpack编译过程的生命周期钩子中，进行编码开发，实现一些功能。</p>
<h3 id="webpack-">webpack插件的组成</h3>
<ul>
<li>一个 JavaScript 命名函数。</li>
<li>在插件函数的 prototype 上定义一个 apply 方法。</li>
<li>指定一个绑定到 webpack 自身的事件钩子。</li>
<li>处理 webpack 内部实例的特定数据。</li>
<li>功能完成后调用 webpack 提供的回调。</li>
</ul>
<h3 id="webpack-">webpack的生命周期钩子</h3>
<table>
<thead>
<tr>
<th style="text-align:center">钩子</th>
<th style="text-align:center">作用</th>
<th style="text-align:center">参数</th>
<th style="text-align:center">类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">entryOption</td>
<td style="text-align:center">在处理了webpack选项的entry配置后调用</td>
<td style="text-align:center">context, entry</td>
<td style="text-align:center">SyncBailHook</td>
</tr>
<tr>
<td style="text-align:center"><strong>afterPlugins</strong></td>
<td style="text-align:center">在初始化内部插件列表后调用。</td>
<td style="text-align:center">compiler</td>
<td style="text-align:center">SyncHook</td>
</tr>
<tr>
<td style="text-align:center">afterResolvers</td>
<td style="text-align:center">Compiler初始化完毕后调用。</td>
<td style="text-align:center">compiler</td>
<td style="text-align:center">SyncHook</td>
</tr>
<tr>
<td style="text-align:center">environment</td>
<td style="text-align:center">在准备编译器环境时调用，在对配置文件中的插件进行初始化之后立即调用。</td>
<td style="text-align:center">无</td>
<td style="text-align:center">SyncHook</td>
</tr>
<tr>
<td style="text-align:center">afterEnvironment</td>
<td style="text-align:center">在environment钩子之后立即调用，当编译器环境设置完成时。</td>
<td style="text-align:center">无</td>
<td style="text-align:center">SyncHook</td>
</tr>
<tr>
<td style="text-align:center"><strong>beforeRun</strong></td>
<td style="text-align:center">在运行Compiler之前调用。</td>
<td style="text-align:center">compiler</td>
<td style="text-align:center">AsyncSeriesHook</td>
</tr>
<tr>
<td style="text-align:center"><strong>run</strong></td>
<td style="text-align:center">Compiler开始工作时调用。</td>
<td style="text-align:center">compiler</td>
<td style="text-align:center">AsyncSeriesHook</td>
</tr>
<tr>
<td style="text-align:center">watchRun</td>
<td style="text-align:center">在新的编译被触发但在实际开始编译之前，在监视模式期间执行插件。</td>
<td style="text-align:center">compiler</td>
<td style="text-align:center">AsyncSeriesHook</td>
</tr>
<tr>
<td style="text-align:center">normalModuleFactory</td>
<td style="text-align:center">NormalModuleFactory创建后调用。</td>
<td style="text-align:center">normalModuleFactory</td>
<td style="text-align:center">SyncHook</td>
</tr>
<tr>
<td style="text-align:center">contextModuleFactory</td>
<td style="text-align:center">ContextModuleFactory创建后运行插件。</td>
<td style="text-align:center">contextModuleFactory</td>
<td style="text-align:center">SyncHook</td>
</tr>
<tr>
<td style="text-align:center">beforeCompile</td>
<td style="text-align:center">创建compilation参数后执行插件。</td>
<td style="text-align:center">compilationParams</td>
<td style="text-align:center">AsyncSeriesHook</td>
</tr>
<tr>
<td style="text-align:center">compile</td>
<td style="text-align:center">beforeCompile在创建新编辑之前立即调用。</td>
<td style="text-align:center">compilationParams</td>
<td style="text-align:center">SyncHook</td>
</tr>
<tr>
<td style="text-align:center">thisCompilation</td>
<td style="text-align:center">在触发compilation事件之前，在初始化编译时调用。</td>
<td style="text-align:center">compilation，compilationParams</td>
<td style="text-align:center">SyncHook</td>
</tr>
<tr>
<td style="text-align:center">compilation</td>
<td style="text-align:center">创建compilation后运行插件。</td>
<td style="text-align:center">compilation，compilationParams</td>
<td style="text-align:center">SyncHook</td>
</tr>
<tr>
<td style="text-align:center"><strong>make</strong></td>
<td style="text-align:center">在完成编译前调用。</td>
<td style="text-align:center">compilation</td>
<td style="text-align:center">AsyncParallelHook</td>
</tr>
<tr>
<td style="text-align:center"><strong>afterCompile</strong></td>
<td style="text-align:center">在完成编译后调用。</td>
<td style="text-align:center">compilation</td>
<td style="text-align:center">AsyncSeriesHook</td>
</tr>
<tr>
<td style="text-align:center"><strong>shouldEmit</strong></td>
<td style="text-align:center">在发射assets之前调用。应该返回一个告诉是否发射出去的布尔值。</td>
<td style="text-align:center">compilation</td>
<td style="text-align:center">SyncBailHook</td>
</tr>
<tr>
<td style="text-align:center"><strong>emit</strong></td>
<td style="text-align:center">向assets目录发射assets时调用</td>
<td style="text-align:center">compilation</td>
<td style="text-align:center">AsyncSeriesHook</td>
</tr>
<tr>
<td style="text-align:center"><strong>afterEmit</strong></td>
<td style="text-align:center">在将assets发送到输出目录后调用。</td>
<td style="text-align:center">compilation</td>
<td style="text-align:center">AsyncSeriesHook</td>
</tr>
<tr>
<td style="text-align:center"><strong>done</strong></td>
<td style="text-align:center">编译完成后调用。</td>
<td style="text-align:center">stats</td>
<td style="text-align:center">AsyncSeriesHook</td>
</tr>
<tr>
<td style="text-align:center">failed</td>
<td style="text-align:center">如果编译失败，则调用。</td>
<td style="text-align:center">error</td>
<td style="text-align:center">SyncHook</td>
</tr>
<tr>
<td style="text-align:center">invalid</td>
<td style="text-align:center">在watching compilation失效时调用。</td>
<td style="text-align:center">fileName，changeTime</td>
<td style="text-align:center">SyncHook</td>
</tr>
<tr>
<td style="text-align:center">watchClose</td>
<td style="text-align:center">在watching compilation停止时调用。</td>
<td style="text-align:center">无</td>
<td style="text-align:center">SyncHook</td>
</tr>
</tbody>
</table>
<h3 id="-plugin">实现一个简单的plugin</h3>
<p><code>compiler.hooks.done</code>表示编译完成后调用的钩子，所以只需要在这个阶段注册时间，当打包完成会自动回调这个函数</p>
<pre><code class="lang-js">class HelloWorldPlugin {
  apply(compiler) {
    compiler.hooks.done.tap(&#39;Hello World Plugin&#39;, (stats) =&gt; {
      console.log(&#39;Hello World!&#39;);
    });
  }
}

module.exports = HelloWorldPlugin;
</code></pre>
<h3 id="-html-webpack-plugin">实现一个html-webpack-plugin</h3>
<p>使用html-webpack-plugin非常简单，而且功能非常好用，可以将指定的html模板复制一份输出到dist目录下，同时会自动引入bundle.js</p>
<p>如何自己实现？</p>
<ol>
<li>编写一个自定义插件，注册<code>afterEmit</code>钩子</li>
<li>根据创建对象时传入的template属性来读取html模板</li>
<li>使用工具分析HTML，推荐使用cheerio，可以直接使用jQuery api</li>
<li>循环遍历webpack打包的资源文件列表，如果有多个bundle就都打包进去（可以根据需求自己修改，因为可能有chunk，一般只引入第一个即可）</li>
<li>输出新生成的HTML字符串到dist目录中</li>
</ol>
<pre><code class="lang-js">const path = require(&#39;path&#39;)
const fs = require(&#39;fs&#39;)
const cheerio = require(&#39;cheerio&#39;)
module.exports = class HTMLPlugin {
  constructor(options) {
    // 传入filename和template
    this.options = options
  }
  apply(compiler) {
    compiler.hooks.afterEmit.tap(&#39;HTMLPlugin&#39;, compilation =&gt; {
      // 根据模板读取html文件内容
      let result = fs.readFileSync(this.options.template, &#39;utf-8&#39;)
      // 使用cheerio来分析HTML
      let $ = cheerio.load(result)
      // 创建script标签后插入HTML中
      Object.keys(compilation.assets).forEach(item =&gt; $(`&lt;script src=&quot;${item}&quot;&gt;&lt;/script&gt;`).appendTo(&#39;body&#39;))
      // 转换成新的HTML并写入到dist目录中
      fs.writeFileSync(path.join(process.cwd(), &#39;dist&#39;, this.options.filename), $.html())
    })
  }
}
</code></pre>
<p><strong>Compiler和Compilation的区别</strong></p>
<ul>
<li><strong>compiler 对象表示不变的webpack环境，是针对webpack的</strong></li>
<li><strong>compilation 对象针对的是随时可变的项目文件，只要文件有改动，compilation就会被重新创建。</strong></li>
</ul>
<h3 id="-itheima-pack-plugin-">在itheima-pack中添加plugin的功能</h3>
<h4 id="tapable-">tapable简介</h4>
<p>在webpack内部实现事件流机制的核心就在于<strong>tapable</strong>，有了它就可以通过事件流的形式，将各个插件串联起来，tapable类似于node中的events库，核心原理也是<strong>发布订阅模式</strong></p>
<p>基本用法如下</p>
<ol>
<li>定义钩子</li>
<li>使用者注册事件</li>
<li>在合适的阶段调用钩子，触发事件</li>
</ol>
<pre><code class="lang-js">let { SyncHook } = require(&#39;tapable&#39;)
class Lesson {
  constructor() {
    this.hooks = {
      html: new SyncHook([&#39;name&#39;]),
      css: new SyncHook([&#39;name&#39;]),
      js: new SyncHook([&#39;name&#39;]),
      react: new SyncHook([&#39;name&#39;]),
    }
  }
  study() {
    console.log(&#39;开班啦，同学们好！&#39;)
    console.log(&#39;开始学html啦，同学们好！&#39;)
    this.hooks.html.call(&#39;小明&#39;)
    console.log(&#39;开始学css啦，同学们好！&#39;)
    this.hooks.css.call(&#39;小花&#39;)
    console.log(&#39;开始学js啦，同学们好！&#39;)
    this.hooks.js.call(&#39;小黑&#39;)
    console.log(&#39;开始学react啦，同学们好！&#39;)
    this.hooks.react.call(&#39;紫阳&#39;)
  }
}

let l = new Lesson()
l.hooks.html.tap(&#39;html&#39;, () =&gt; {
  console.log(&#39;我要写个淘宝！！！挣他一个亿！&#39;)
})

l.hooks.react.tap(&#39;react&#39;, (name) =&gt; {
  console.log(&#39;我要用react构建一个属于自己的王国！&#39; + name + &#39;老师讲的真好！！！&#39;)
})
l.study()
</code></pre>
<p>通过该案例可以看出，如果需要在学习的不同阶段，做出不同的事情，可以通过发布订阅模式来完成。而tapable可以帮我们很方便的实现发布订阅模式，同时还可以在调用时传入参数。</p>
<p>以上只是最基础的同步钩子演示，如果感兴趣，可以查阅官方文档，并练习对应的其他钩子，以下是tapable对外暴露的所有钩子：</p>
<pre><code class="lang-js">exports.Tapable = require(&quot;./Tapable&quot;);
exports.SyncHook = require(&quot;./SyncHook&quot;);
exports.SyncBailHook = require(&quot;./SyncBailHook&quot;);
exports.SyncWaterfallHook = require(&quot;./SyncWaterfallHook&quot;);
exports.SyncLoopHook = require(&quot;./SyncLoopHook&quot;);
exports.AsyncParallelHook = require(&quot;./AsyncParallelHook&quot;);
exports.AsyncParallelBailHook = require(&quot;./AsyncParallelBailHook&quot;);
exports.AsyncSeriesHook = require(&quot;./AsyncSeriesHook&quot;);
exports.AsyncSeriesBailHook = require(&quot;./AsyncSeriesBailHook&quot;);
exports.AsyncSeriesWaterfallHook = require(&quot;./AsyncSeriesWaterfallHook&quot;);
exports.HookMap = require(&quot;./HookMap&quot;);
exports.MultiHook = require(&quot;./MultiHook&quot;);
</code></pre>
<h4 id="-tapable-itheima-pack-plugin-">利用tapable实现itheima-pack的plugin功能</h4>
<p>在Compiler构造时，创建对应的钩子即可</p>
<pre><code class="lang-js">    // Compiler的构造函数内部定义钩子
    this.hooks = {
      afterPlugins: new SyncHook(),
      beforeRun: new SyncHook(),
      run: new SyncHook(),
      make: new SyncHook(),
      afterCompile: new SyncHook(),
      shouldEmit: new SyncHook(),
      emit: new SyncHook(),
      afterEmit: new SyncHook([&#39;compilation&#39;]),
      done: new SyncHook(),
    }

    // 触发所有插件的apply方法，并传入Compiler对象
    if (Array.isArray(this.config.plugins)) {
      this.config.plugins.forEach(plugin =&gt; {
        plugin.apply(this)
      })
    }
</code></pre>
<p>在合适的时机调用对应钩子的call方法即可，如需传入参数，可以在对应的钩子中定义好需要传入的参数，call时直接传入</p>
<p><img src="./images/1561895540321.png" alt="1561895540321"></p>
<h1 id="-6-">第6章 课程总结</h1>
<ul>
<li>webpack基础配置<ul>
<li>安装：本地安装即可，无需全局安装</li>
<li>使用：CLI的方式或配置脚本使用配置文件</li>
<li>配置：<ul>
<li>开发时工具：watch、dev-server、webpack-dev-middleware、sourceMap</li>
<li>loaders：css-loader、style-loader、less-loader、sass-loader、url-loader、babel-loader、</li>
<li>plugins：html-webpack-plugin、clean-webpack-plugin、copy-webpack-plugin、BannerPlugin</li>
</ul>
</li>
</ul>
</li>
<li>webpack高级配置<ul>
<li>img标签资源处理</li>
<li>多页应用打包</li>
<li>第三方库的引入方式</li>
<li>区分配置文件打包</li>
<li>环境变量</li>
<li>proxy</li>
<li>HMR</li>
</ul>
</li>
<li>webpack性能优化<ul>
<li>webpack自带优化详解</li>
<li>css优化<ul>
<li>提取到单独文件</li>
<li>自动添加前缀</li>
<li>压缩注意事项</li>
</ul>
</li>
<li>js优化<ul>
<li>代码分离：手动配置多入口、抽取公共代码、懒加载、SplitChunksPlugin参数详解</li>
<li>noParse</li>
<li>IgnorePlugin</li>
<li>DllPlugin：将固定库抽取成动态链接库节省资源</li>
</ul>
</li>
<li>多进程打包</li>
<li>浏览器缓存</li>
<li>打包分析</li>
<li>Prefetching</li>
</ul>
</li>
<li>webpack原理<ul>
<li>分析bundle文件</li>
<li>手写基础的webpack</li>
<li>利用AST完成代码转译</li>
<li>手写loader并给自己的webpack添加loader功能</li>
<li>webpack中tapable的应用</li>
<li>手写plugin并给自己的webpack添加plugin功能</li>
</ul>
</li>
</ul>
<p>学习不是百米冲刺，而是一场马拉松，现在所学只是起点，更多的是需要大家找到学习方法，不断的学习提升自己，一起加油！</p>

          	</article>
        </div>
		</div>
  </body>
</html>
<script type="text/javascript" src="../preview/toc/js/jquery-1.4.4.min.js"></script>
<script type="text/javascript" src="../preview/toc/js/jquery.ztree.all-3.5.min.js"></script>
<script type="text/javascript" src="../preview/toc/js/ztree_toc.js"></script>
<script type="text/javascript" src="../preview/toc_conf.js"></script>

<SCRIPT type="text/javascript" >
<!--
$(document).ready(function(){
    var css_conf = eval(markdown_panel_style);
    $('#readme').css(css_conf)
    
    var conf = eval(jquery_ztree_toc_opts);
		$('#tree').ztree_toc(conf);
});
//-->
</SCRIPT>